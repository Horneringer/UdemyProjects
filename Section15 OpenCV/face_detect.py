"""
Информация о данном алгоритме


Для начала давайте разберемся, как распознать лицо на фотографии. Во-первых, нужно найти, где на фото расположено
лицо человека и не спутать его с часами на стене и кактусом на подоконнике. Казалось бы, простая задача для человека,
оказывается не такой простой для компьютера. Для того, чтобы найти лицо мы должны выделить его основные компоненты,
такие как нос, лоб, глаза, губы и т.д. Для этого будем использовать шаблоны (они же примитивы Хаара)

Если шаблоны соответствуют конкретным областям на изображении, будем считать, что на изображении есть человеческое
лицо. На самом деле подобных шаблонов гораздо больше. Для каждого из них считается разность между яркостью белой и
черной областей. Это значение сравнивается с эталоном и принимается решение о том, есть ли здесь часть человеческого
лица или нет. Этот метод называется методом Виолы-Джонса (так же известен как каскады Хаара). Давайте представим,
что у нас на фотографии не одно большое лицо, а много мелких. Если применить шаблоны ко всей картинке мы не найдем
там лиц, т.к. они будут меньше шаблонов. Для того чтобы искать на всем фото лица разных размеров используется метод
скользящего окна. Именно внутри этого окна и высчитываются примитивы. Окно как бы скользит по всему изображению.
После каждого прохождения изображения окно увеличивается, чтобы найти лица большего масштаба.

"""

import cv2

face_cascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')  # создаём переменную, где будем хранить
# каскад лица(посмотреть подробнее что это), в параметрах указываем путь к xml файлу с каскадом (# для детектирования
#  лиц используем каскады Хаара) Параметр пути содержит имя файла с уже готовыми значениями для распознавания лиц.

img = cv2.imread('photo.jpg')  # читаем изображение, на котором хотим найти лица; по умолчанию в RGB, но в оттенках
# серого изображение лица ищется c большей точностью

gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  # конвертируем изображение из RGB в оттенки серого

faces = face_cascade.detectMultiScale(gray_img, scaleFactor=1.05, minNeighbors=5)  # определяем области где есть лица

'''image – исходное изображение

 scaleFactor – определяет то, на сколько будет увеличиваться скользящее окно поиска на
каждой итерации. 1.1 означает на 10%, 1.05 на 5% и т.д. Чем больше это значение, тем быстрее работает алгоритм.

minNeighbors — Чем больше это значение, тем более параноидальным будет поиск и тем чаще он будет пропускать реальные
лица, считая, что это ложное срабатывание. Оптимальное значение 3-6.

'''

for x, y, w, h in faces:  # отрисовываем прямоугольник по имеющимся у нас координатам
    img = cv2.rectangle(img, (x, y), (x + w, y + h), (0, 255, 0), 3)  # в параметры передаём изображение(куда добавить
    # прямоугольник), кортеж с координатами левой верхней точки и кортеж с координатами правой нижней точки(
    # вычисляются через ширину и высоту), в третьем кортеже задаём цвет прямоугольника тремя числами,
    # которые обозначают количество синего-blue/зеленого-green/красного-red цвета в получаемом(по итогу получили
    # зеленый), последний параметр отвечает за толщину линии прямоугольника

print(faces)  # получим массив с 4-мя значениями; первые два значения - координаты X и Y верхнего левого угла лица,
# 3-е и 4-е значение - ширина и высота (области)лица соответственно

resized = cv2.resize(img, (int(img.shape[1]/3), int(img.shape[0]/3)))

cv2.imshow('You were noticed!', resized)
cv2.waitKey(0)
cv2.destroyAllWindows()
